<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Test | ExampleSite</title><meta name=keywords content="first"><meta name=description content="Desc Text."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Test"><meta property="og:description" content="Desc Text."><meta property="og:type" content="article"><meta property="og:url" content="https://examplesite.com/test/"><meta property="og:image" content="https://examplesite.com/%3Cimage%20path/url%3E"><meta property="article:section" content><meta property="article:published_time" content="2022-05-09T19:18:11+08:00"><meta property="article:modified_time" content="2022-05-09T19:18:11+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://examplesite.com/%3Cimage%20path/url%3E"><meta name=twitter:title content="Test"><meta name=twitter:description content="Desc Text."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Test","item":"https://examplesite.com/test/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Test","name":"Test","description":"Desc Text.","keywords":["first"],"articleBody":" 实验一 第一部分 PC的启动 整个使用都运行在QEMU模拟器上，该模拟器可以每行调试代码，比较方便的观察到整个系统的启动情况，以及操作系统做了啥；\n练习1 首先告诉你该练习目的是要你熟悉汇编语言、PC启动过程、和QEMU模拟器的调试过程。没什么实质的内容，直接下一个  PC的物理地址空间 在早期的PC中，CPU是16bits的8088处理器，只支持访问1MB的物理内存，物理地址空间从0x00000000到0x000FFFFF而不是0xFFFFFFFF,低640KB的空间被标记为low memory，作为RAM使用；\n从0x000A0000到0x00FFFFF，被保留作为硬件外设，比如VGA的缓冲区，这个区域保留着最重要的BIOS（基本输入输出系统），占64KB从0x000FF0000开始，到0x000FFFFFF，早期的PC中，BIOS是只读的，现在BIOS都存在FLash中，是可以多次写入的，BIOS的主要功能是系统的基本初始化，包括显卡、内存大小。在这些初始化之后，BIOS将从硬盘中加载操作系统；\n +------------------+ 虽然CPU的支持更大的寻址空间，为了兼容之前写的BIOS，前1MB的物理地址的布局还是被保留了下来；\nROM中的BIOS 这一小节，要用gdb调试BIOS启动过程；\ntu\n可以看到第一条指令就是\n[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b 从打印的指令可以看到：\n 首先PC在物理地址0x000ffff0的位置启动，这在BIOS的存储Rom中是非常高的位置； 启动时的状态是 CS = 0xf000（代码段寄存器） IP = 0xfff0(指令指针寄存器)； 第一条指令是jmp指令，将CS = 0xf000, IP = 0xe05b；\n首先这个物理地址0x000ffff0是一个固定值，不过为什么放在这个高的位置，是一个问题，其次，ROM如何映射到这个地址，也是一个问题； 接下来就是对CPU寻址模式的一个解释：总的来说  物理地址 = 代码段地址 为什么要这样做？因为此时CPU还是16bits寻址空间，数据总线是8bits，纯按这个方式寻址，最大的寻址空间是2^16 * 1 = 64KB，可是当前状态的CPU可以用的物理内存有1MB，需要20bits的寄存器，于是用这样一个段 + 偏移量的形式，避免了实际可用内存大于寻址空间的问题。\n练习二 使用GDB跟踪几条指令，猜测BIOS在干吗，其实也没实际的内容；  第二部分 Boot loader 对于PC来说，硬盘被划分为512byte的区域，叫做扇区，扇区是一次磁盘操作的最小区域，如果该磁盘是可启动的，该磁盘第一个扇区叫做启动扇区，也就是bootloader代码的存储区域。当BIOS找到这个可以启动的扇区时，他将这个512byte扇区的内容加在到0x7c00到0x7dff，然后通过jmp CS:IP指令调到这个区域，此时就完成的BIOS到BootLoader的转换，这些地址就像BIOS启动区域一样，都是人为自由规定的，但是对PC来说，是固定的；\n在6.828的实验中，Bootloader包括一个汇编源文件boot/boot.S，与.c文件 boot/main.c, BootLoader的主要目的有两个：\n 将处理器从实模式切换到32bits的保护模式，这两者的主要区别给出的参考资料中有介绍，主要是寻址空间从1MB扩展到4GB，其次是引入了虚拟内存的分页内存机制； Bootloader通过x86的特定IO指令，将内核从磁盘中读取出来；\n当你看懂了bootloader的源码之后，看看obj/boot/boot.asm文件，该文件是bootloader的反汇编文件，阅读反汇编文件可以更加清晰的看到boot loader的代码所在位置，同样对于obj/kern/kernal.asm  练习三 设立一个断点在0x7c00,也就是bootloader所在的启动扇区的位置，继续执行直到命中这个断点，跟踪boot.s的代码，也可以使用GDB的x/i指令去获取任意机器指令的反汇编指令，对比boot.s与boot.asm的内容。 追踪到bootmain函数中，具体到readsect()函数中，将汇编指令与C语言代码进行对应，回到bootmian函数中，找到内核文件从磁盘读取到内存的for循环代码，并找到循环结束后执行的语句，并再这位置设置断点，运行到该断点，然后跟踪直到bootloader结束  要回答以下四个问题：\n 处理器从什么时候开始执行 32 位代码？究竟是什么导致从16位模式切换到32位模式？ bootloader最后一条执行的指令是那个？ kernal执行的第一条指令是？ 内核执行的第一条指令在哪里？ bootloader怎么直到他要读取多少个扇区才能吧内核加载到内存，这些信息在哪里可以找到？  先看练习三，汇报代码注释其实已经写的比较详细了\n.globl start start: .code16 # Assemble for 16-bit mode cli # Disable interrupts 关中断 cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax,%ax # Segment number zero ax寄存器清零 movw %ax,%ds # - Data Segment 用ax寄存器清零DS ES SS寄存器 movw %ax,%es # - Extra Segment movw %ax,%ss # - Stack Segment 这几条指令主要是关闭中断，清理了DS ES SS寄存器的值；\n # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this. seta20.1: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.1 movb $0xd1,%al # 0xd1 - port 0x64 outb %al,$0x64 seta20.2: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.2 movb $0xdf,%al # 0xdf - port 0x60 outb %al,$0x60 可以看到seta20.1是一个轮询的过程，一直查询的是0x64里面的第二个bit位是否是0，inb指令是直接从硬件IO口上读取数据，这里是将0x64的IO口，读取到al寄存器中，test指令做得就是and操作， 一个数与上0x02查询的就是第1个bit位是否1，若为1，ZF寄存器就是1，jnz是jump not zero的意思，直到ZF寄存器是0，才跳出这个循环；\n接下来是通过out指令将0xd1送到地址为0x64的IO端口中; 告诉cpu，下一行命令写到0x60寄存器，并且要被写到804x输出端口上，后续操作与之前相同，再次查询0x64的bit1位是否为1，也就是查询数据写入是否成功，如果成功，接下来就再向0x60口，写入0xdf； 具体含义参考这个网站：https://bochs.sourceforge.io/techspec/PORTS.LST\n接下来代码：\n # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to their physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 # Bootstrap GDT .p2align 2 # force 4 byte alignment gdt: SEG_NULL\t# null seg SEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg SEG(STA_W, 0x0, 0xffffffff)\t# data seg gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt GDT表 接下来就是一个比较重要的概念了：gdt（global Descriptor Table 全局描述表），它是一种结构体数据，被用于定义内存分段，比如，代码段，数据段。对不同的段限制其相应的操作限制，也就是rwx；\n从代码中看到，他先使用指令lgdt，将gdtdesc地址存到全局描述表寄存器中；这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器由48位组成，其中低16位表示该表长度，高32位表该表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的最后一个位置的偏移量和起始地址。我们可以在这个文件的末尾看到gdtdesc；\ngdt表中包含三个种类，nullseg、codeseg、dataseg，xv6没有分段机制，代码段与数据段都是放在一起的，都可以使用0x00到0xffffffff = 4G内存; 那么这三种类有什么不同，这里是通过宏定义SEG（在inc/mmu.h中）来初始化，主要包括读、写、执行权限，存储的起始地址与最大地址；\n在初始化gdt后，后续的几条指令就很简单了，把寄存器CR0的值取出来，逻辑或0x01，再写入CR0中，在inc/mmu.h中，该值就是启动保护模式的意思；\n后续执行的就是32位模式的跳转工作，跳转到保护模式下的代码段，IP寄存器直接指向标志符protcseg，再使用数据段初始化其余段寄存器，包括DS、SS等寄存器；\n # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg .code32 # Assemble for 32-bit mode protcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # - DS: Data Segment movw %ax, %es # - ES: Extra Segment movw %ax, %fs # - FS movw %ax, %gs # - GS movw %ax, %ss # - SS: Stack Segment # Set up the stack pointer and call into C. movl $start, %esp call bootmain 在boot.s最后，使用call指令，调用bootmain函数，在反汇编文件obj/boot/boot.asm中可以看到，函数名就是一个指令地址，调用前后的esp、eip地址对比如下图,调用前，eip指向是当前指令地址，执行call之后，栈中被推入了call bootmain 下一条指令的地址，作为函数返回地址，同时在新函数的开头，更新ebp的值，push %esp, mov %esp, %ebp作为被调用函数的栈顶,以上就是一般函数调用的过程;\n\treadseg((uint32_t) ELFHDR, SECTSIZE*8, 0); 7d2e:\t52 push %edx 7d2f:\t6a 00 push $0x0 7d31:\t68 00 10 00 00 push $0x1000 7d36:\t68 00 00 01 00 push $0x10000 7d3b:\te8 a2 ff ff ff call 7ce2  readseg(),前面三条指令是形参的初始化，这里就可以看到，形参的初始化顺序是从后往前初始化的，且是由调用者进行初始化，接下来就进入readseg函数中，bootmain主要的流程，先读一个page，也就是4096个字节，首先校验ELF的magic是否正确，如果正确就从该结构体中的另一个成员中读到起始地址与大小，然后调用readseg函数从磁盘中加载内核，然后将entry这个成员作为函数指针进行调用，此时已经进行操作系统内核；\n这小节后续还需要再细化分析；\n小总结 这部分练习内容，主要是要你理解一下bootloader的主要工作，那么现在可以主要总结一下，BootLoader的主要工作包括：\n CPU的工作模式从实模式到保护模式的切换；由于现在还没有MMU，主要是通过GDT进行读、写、执行的权限管理，目前保护模式只区分了代码段与数据段，也没有在内存中将其区分，这部分对应的代码是boot.s部分； 从硬盘指定的地址将内核加载到内存中，具体方式是，先读4096个字节，这其中就包括内核一些信息，包括magicnum（校验数字）、内核起始地址，大小等，如果校验成功，根据这些信息从硬盘中读取一定数量的字节加载到内存，读取完毕之后，通过elf结构体中的entry这个函数入口进入操作系统的内核，由此进入了操作系统内核；  加载内核 练习四 C语言学习，在书中《The C Programming Language》中，阅读5.1到5.5节。然后下载pointers.c的代码，并且编译运行它，确保你理解在屏幕上打印出来的所有的值是怎么来的。尤其要重点理解第1行，第6行的指针地址是如何得到的，以及在第2行到第4行的值是如何得到的，还有为什么在第5行打印出来的值看起来像程序崩溃了。  这里首先介绍了一下ELF文件，参考https://en.wikipedia.org/wiki/Executable_and_Linkable_Format，或者直接在inc/elf.h中的struct可以看到该类文件的固定长度的elf头，其中包括elf文件的分段方式，包括.text段、.rodata段、.data段、.bss段等，具体可以参考https://zhuanlan.zhihu.com/p/348026261；\n练习五 在boot/Makefrag文件中，修改链接地址，使用GDB追踪修改链接后的BootLoader，看看是否有问题；  这里大概涉及到的是重定向的知识，暂时不太明白；\n练习六 这个练习中，需要将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启一下Qemu。在Bios进入boot loader之前，内存地址0x00100000处8个字的内容，然后进入boot loader运行到内核开始处停止，再看下这个地址处的值。为什么二者不同？第二次这个内存处所存放的值的含义是什么？  首先内核程序的入口地址是0x1000c,这点可以使用objdump -f obj/kern/kernel可以得到内核程序的入口；\n实验结果如下图：\n可以看到刚进入bootloader，内存地址0x100000之后存的都是0，运行到内核入口之前，内存地址存的值已经不是0了，从obj/kern/kernel.asm中可以看到，这个已经是内核的代码段的内容了，在bootloader将内核加载到内存之后，这个内存的值已经得到了修改；\n第三部分 内核 在之前的objdump的练习中，已经看到了VMA与LMA的不同，也就是加载地址与链接地址的不同，这里我们需要深入探究一下；\n使用虚拟地址空间 练习7 使用GDB跟踪内核代码，停在`movl %eax, %cr0`，查看内存0x00100000与0xf0100000，执行完这条语句后，再次查看这两个内存,解释一下为什么是这个样子的  这条语句就是启动内存映射的一个地址，在此之前内核还未建立起内存映射关系，在此之后，建立了内存映射关系，两个地址被映射到相同的物理地址中,具体如何实现看下反汇编代码：\n\t# sufficient until we set up our real page table in mem_init # in lab 2. # Load the physical address of entry_pgdir into cr3. entry_pgdir # is defined in entrypgdir.c. movl\t$(RELOC(entry_pgdir)), %eax f0100015:\tb8 00 90 11 00 mov $0x119000,%eax movl\t%eax, %cr3 f010001a:\t0f 22 d8 mov %eax,%cr3 # Turn on paging. movl\t%cr0, %eax f010001d:\t0f 20 c0 mov %cr0,%eax orl\t$(CR0_PE|CR0_PG|CR0_WP), %eax f0100020:\t0d 01 00 01 80 or $0x80010001,%eax movl\t%eax, %cr0 f0100025:\t0f 22 c0 mov %eax,%cr0 # Now paging is enabled, but we're still running at a low EIP # (why is this okay?). Jump up above KERNBASE before entering # C code. mov\t$relocated, %eax f0100028:\tb8 2f 00 10 f0 mov $0xf010002f,%eax jmp\t*%eax f010002d:\tff e0 jmp *%eax f010002f : relocated: # Clear the frame pointer register (EBP) # so that once we get into debugging C code, # stack backtraces will be terminated properly. movl\t$0x0,%ebp\t# nuke frame pointer 总的来说，先把entry_dir的地址存到cr3寄存器中作为一级页表，然后在启动内存映射模式，这里有个小问题，就是启动内存映射模式后，EIP如何还能正确被映射到指向下一个指令：\n__attribute__((__aligned__(PGSIZE))) pde_t entry_pgdir[NPDENTRIES] = { // Map VA's [0, 4MB) to PA's [0, 4MB) [0] = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P, // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB) [KERNBASEPDXSHIFT] = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W }; 由虚拟内存的地址机制，高10位是entry_pgdir的偏移量，这个entry_pgdir只初始化了两个内容，entry_pgdir[0]与entry_pgdir[960]，正好对应的是0x00100028与0xf0100028中高10位数值，他们内容（除了权限问题之外）是一样的，说明这两个一级页表映射的地址区间是同一个page，于是EIP的虚拟内存映射之后，地址没有变化，如同entry_pgdir注释所示；\n格式化打印至控制台 练习8 补全printf()函数的%o的情况  还需要回答这些问题：\n 解释printf.c与console.c，特别是console.c那些函数被导出，他们是怎么被printf.c调用？ 解释console.c中的下列语句的含义：   if (crt_pos = CRT_SIZE) { int i; memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t)); for (i = CRT_SIZE - CRT_COLS; i 跟踪以下代码  int x = 1, y = 3, z = 4; cprintf(\"x %d, y %x, z %d\\n\", x, y, z); 执行以下代码   unsigned int i = 0x00646c72; cprintf(\"H%x Wo%s\", 57616, \u0026i); 输出的的字符是啥，为什么？ 5. cprintf(\"x=%d y=%d\", 3);输出是啥，为什么？\n假设GCC的形参默认初始化顺序是，从左到右，如何更改cprintf函数的接口，以便于可变数量的参数传递给该函数;  这个练习很简单，直接将%u系列的复制下来，将base改成8就可以；\ncase 'o': num = getint(\u0026ap, lflag); base = 8; goto number; 接下来回答问题:\n  从代码中就可以看到，从函数printf.c中通过函数指针调用putch()，而putch函数中调用cputchar函数是console.c中的函数接口，用于输出一个字符串；\n  这段代码的主要目的是，如果屏幕的字符串长度大于显示的最大字符串，首先使用memmove将整体将buf前移动一行（宏定义为80 * 2个字节），这里必须使用memmove，因为内存区域是有重叠的，memcpy会导致数据错误的，然后将最后一行的数据用空格填充，将当前字符串位置减去一行大小；\n  这里其实是考察GCC默认的形参初始化方式，从汇编代码来看，默认的形参初始化方式是从右往左进行入栈初始化的,并且可以看到指针操作的具体是通过lea命令进行实现的；\n  \t//lab1 exercise 8 int x = 1, y = 3, z = 4; cprintf(\"x %d, y %x, z %d\\n\", x, y, z); f01000f0:\t6a 04 push $0x4 f01000f2:\t6a 03 push $0x3 f01000f4:\t6a 01 push $0x1 f01000f6:\t8d 83 6a 08 ff ff lea -0xf796(%ebx),%eax f01000fc:\t50 push %eax f01000fd:\te8 9b 09 00 00 call f0100a9d  跑出来的效果是  x 1, y 3, z 4 He110 World x=3 y=-267321364 57616的16进制就是110，这个没啥好说的，关键是0x00646c72按照%s打印是rld，这个就涉及到计算机的存储形式了，计算机按照小端序列进行存储，也就是说i = 0x00646c72实际存储方式，地址从低到高分别是72 6c 64 00形式,其ASC码值对应就是字符串\"rld\\0\"，所以打印出来为He110 World了；\n y=之后打印出来的数字是之前栈中使用的数字，但是并无实际意义，这个问题是告诉你，printf对于参数缺省的情况下的实际运行情况与原理；\n  这种情况只能声明一个参数数量这个变量；（函数可变数量形参这里还要继续看）\n  栈 练习9 找到哪里是内核初始化的代码，内核的栈起点在哪里，内核栈的保留的区域的终点在哪里？  ebp（基指针）寄存器主要通过软件习惯与堆栈相关联。 在进入 C 函数时，函数会更新ebp的地址，表示这里才是该函数栈的起点，那么在程序执行期间的任何变量，都可以通过跟踪保存的ebp要到达的程序中的点。 此功能可能特别有用，例如，当某个特定函数由于传递了错误参数而导致异常时，但您不确定是谁传递了错误参数。堆栈回溯可让您找到有问题的函数。\n回答： 内核初始化栈是是entry.S中语句\nmovl\t$0x0,%ebp\t# nuke frame pointer # Set the stack pointer movl\t$(bootstacktop),%esp 栈的大小在inc/memlayout.h中定义为8 * 4096大小，也就是32KB；（目前还不确定是为什么ebp在0x00，esp大于ebp）\n练习10 为了熟悉C语言调用函数的规则，找到test_backtrace函数，设一个断点，检验每次调用这个函数时，每层嵌套有有多少个32bits字段被推入栈中，这些字段代表什么意思？  这个实验只需要在test_backtrace()函数中打印出ebp与esp的值就行了，打印结果为：\nentering test_backtrace 5 ebp = 0xf010ffd8, esp = 0xf010ffc0 entering test_backtrace 4 ebp = 0xf010ffb8, esp = 0xf010ffa0 entering test_backtrace 3 ebp = 0xf010ff98, esp = 0xf010ff80 entering test_backtrace 2 ebp = 0xf010ff78, esp = 0xf010ff60 entering test_backtrace 1 ebp = 0xf010ff58, esp = 0xf010ff40 entering test_backtrace 0 ebp = 0xf010ff38, esp = 0xf010ff20 可以看到每次进行函数调用压栈的32bits的字段为32个,其中函数栈帧中，从上到下分别是，临时变量，调用其他函数的形参，调用返回值，函数调用者的ebp地址；\n练习11 完成一个回溯函数，打印ebp、eip和形参值，eip存的是函数返回指令指针，也就是函数返回时将要接管的指令地址，这个值通常指向call指令的下一条指令，为什么？最后，五个十六进制数字，那些是在函数调用前应该被压入栈中的，如果函数形参少于五个呢？（为什么回溯函数不能知道到底有几个形参，这样的局限性应该怎么样被修复）  需要补全的是mon_backtrace函数，主要的问题在于，循环的结束条件吧，读取ebp值可以直接使用read_ebp函数，根据上一个练习的结果，eip的存储地址就是当前函数ebp + 1存储地址，再接着往上就是所用的形参了，此时需要一直回溯到内核启动的函数，也就是第一次设置ebp函数，在练习9中知道第一次设置ebp为0x00；(为什么要保存调用者的ebp的值，只是为了调试还是其他的目的)\n其次，这里的read_ebp函数被声明为inline函数，从汇编上可以看到，inline函数没有使用call命令，而是就地修改了代码，避免了函数调用的开销（形参入栈，eip入栈，局部变量等）；\nint mon_backtrace(int argc, char **argv, struct Trapframe *tf) { // Your code here. cprintf(\"Stack backtrace:\\n\"); for (uint32_t ebp = read_ebp(); ebp != 0x00 ; ebp = *((uint32_t *)ebp)){ cprintf(\" ebp %08x eip %08x args %08x %08x %08x %08x %08x\\n\", ebp, *((uint32_t *)ebp + 1), *((uint32_t *)ebp + 2), *((uint32_t *)ebp + 3), *((uint32_t *)ebp + 4), *((uint32_t *)ebp + 5), *((uint32_t *)ebp + 6)); } return 0; } 练习12 修改栈的回溯函数，对每个eip，找到他的函数名称，源文件名称，行数。 在debuginfo_eip，__STAB_*从哪里来，这个问题先不考虑。现在要完成debuginfo_eip函数，通过二分查找函数stab_binsearch函数找到函数行号； 在你的操作系统中加入backtrace命令，并且实现mon_backtrace函数，调用debuginfo_eip，打印按照固定的格式打印每个栈帧： K backtrace Stack backtrace: ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000 kern/monitor.c:143: monitor+106 ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000 kern/init.c:49: i386_init+59 ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff kern/entry.S:70: +0 K 每行栈帧的eip的文件名字，与行号，接着给出函数名称，和eip相对该函数首条指令的偏移量(monitor+106表示eip相对于monitor函数首行有106字节的偏移量) tip：打印字符串的前n个字符可以使用printf(\"%.*s\", length, string)  这个练习中debuginfo_eip是copy的：\n stab_binsearch(stabs, \u0026lline, \u0026rline, N_SLINE, addr); if (lline eip_line = stabs[lline].n_desc; }else{ cprintf(\"line not find\\n\"); } 后续的mon_backtrace函数直接每次调用debuginfo_eip函数，再将信息打印出来即可：\nint mon_backtrace(int argc, char **argv, struct Trapframe *tf) { // Your code here. cprintf(\"Stack backtrace:\\n\"); for (uint32_t ebp = read_ebp(); ebp != 0x00 ; ebp = *((uint32_t *)ebp)){ uint32_t eipAddr = *((uint32_t *)ebp + 1); cprintf(\" ebp %08x eip %08x args %08x %08x %08x %08x %08x\\n\", ebp, eipAddr, *((uint32_t *)ebp + 2), *((uint32_t *)ebp + 3), *((uint32_t *)ebp + 4), *((uint32_t *)ebp + 5), *((uint32_t *)ebp + 6)); struct Eipdebuginfo info; debuginfo_eip(eipAddr, \u0026info); cprintf(\" %s:%d: %.*s+%d\\n\", info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eipAddr - info.eip_fn_addr); } return 0; } 最后加入新的命令需要看明白monitor函数与runcmd函数，monitor函数每次都从命令行中读取数据，调用runcmd函数，runcmd其实就是做了一个字符串匹配的工作，匹配从静态结构体数组中static struct Command commands[] 匹配函数名，argc argv等变量，再通过该结构体数组中的函数指针调用该函数，弄清楚这个，加入新的命令就很简单了，就是在这个数组中加入函数名称、描述，以及指向对应函数的指针；\n至此，lab1总算是磕磕绊绊的做完了。\n总结 总的来说，lab1做完了解到很多知识，比较有用的是汇编语句（可以再看一遍csapp）、系统栈的管理方式（包括回溯的汇编代码的实现），函数调用规则，包括页表的建立与原理，还没弄明白的是链接与重定向的方面的内容：下图是这个实验主要内容–PC启动的大致总结。\n网上找到的资料记录一下   https://www.cnblogs.com/fatsheep9146/category/769143.html\n  全局描述表 https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8 https://www.geeksforgeeks.org/what-is-global-descriptor-table/ https://wiki.osdev.org/Global_Descriptor_Table https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table\n  函数调用 https://www.tutorialspoint.com/assembly_programming/assembly_procedures.htm https://zhuanlan.zhihu.com/p/24129384 https://blog.csdn.net/theLostLamb/article/details/79950815 https://segmentfault.com/a/1190000016661251\n  页表 https://en.wikipedia.org/wiki/Control_register https://pdos.csail.mit.edu/6.828/2018/readings/i386/s05_02.htm\n  ","wordCount":"1300","inLanguage":"en","image":"https://examplesite.com/%3Cimage%20path/url%3E","datePublished":"2022-05-09T19:18:11+08:00","dateModified":"2022-05-09T19:18:11+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://examplesite.com/test/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"https://examplesite.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://examplesite.com/ accesskey=h title="Home (Alt + H)"><img src=https://examplesite.com/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://examplesite.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://examplesite.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://examplesite.com/>Home</a></div><h1 class=post-title>Test</h1><div class=post-description>Desc Text.</div><div class=post-meta><span title="2022-05-09 19:18:11 +0800 CST">May 9, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/test.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ae%9e%e9%aa%8c%e4%b8%80 aria-label=实验一>实验一</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86-pc%e7%9a%84%e5%90%af%e5%8a%a8 aria-label="第一部分 PC的启动">第一部分 PC的启动</a><ul><li><a href=#%e7%bb%83%e4%b9%a01 aria-label=练习1>练习1</a></li><li><a href=#pc%e7%9a%84%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label=PC的物理地址空间>PC的物理地址空间</a></li><li><a href=#rom%e4%b8%ad%e7%9a%84bios aria-label=ROM中的BIOS>ROM中的BIOS</a></li><li><a href=#%e7%bb%83%e4%b9%a0%e4%ba%8c aria-label=练习二>练习二</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86-boot-loader aria-label="第二部分 Boot loader">第二部分 Boot loader</a><ul><li><a href=#%e7%bb%83%e4%b9%a0%e4%b8%89 aria-label=练习三>练习三</a><ul><li><a href=#gdt%e8%a1%a8 aria-label=GDT表>GDT表</a></li></ul></li><li><a href=#%e5%b0%8f%e6%80%bb%e7%bb%93 aria-label=小总结>小总结</a></li><li><a href=#%e5%8a%a0%e8%bd%bd%e5%86%85%e6%a0%b8 aria-label=加载内核>加载内核</a><ul><li><a href=#%e7%bb%83%e4%b9%a0%e5%9b%9b aria-label=练习四>练习四</a></li><li><a href=#%e7%bb%83%e4%b9%a0%e4%ba%94 aria-label=练习五>练习五</a></li><li><a href=#%e7%bb%83%e4%b9%a0%e5%85%ad aria-label=练习六>练习六</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86-%e5%86%85%e6%a0%b8 aria-label="第三部分 内核">第三部分 内核</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label=使用虚拟地址空间>使用虚拟地址空间</a><ul><li><a href=#%e7%bb%83%e4%b9%a07 aria-label=练习7>练习7</a></li></ul></li><li><a href=#%e6%a0%bc%e5%bc%8f%e5%8c%96%e6%89%93%e5%8d%b0%e8%87%b3%e6%8e%a7%e5%88%b6%e5%8f%b0 aria-label=格式化打印至控制台>格式化打印至控制台</a></li><li><a href=#%e7%bb%83%e4%b9%a08 aria-label=练习8>练习8</a><ul><li><a href=#%e6%a0%88 aria-label=栈>栈</a></li><li><a href=#%e7%bb%83%e4%b9%a09 aria-label=练习9>练习9</a></li><li><a href=#%e7%bb%83%e4%b9%a010 aria-label=练习10>练习10</a></li><li><a href=#%e7%bb%83%e4%b9%a011 aria-label=练习11>练习11</a></li><li><a href=#%e7%bb%83%e4%b9%a012 aria-label=练习12>练习12</a></li></ul></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e7%bd%91%e4%b8%8a%e6%89%be%e5%88%b0%e7%9a%84%e8%b5%84%e6%96%99%e8%ae%b0%e5%bd%95%e4%b8%80%e4%b8%8b aria-label=网上找到的资料记录一下>网上找到的资料记录一下</a></li></ul></div></details></div><div class=post-content><hr><h1 id=实验一>实验一<a hidden class=anchor aria-hidden=true href=#实验一>#</a></h1><h2 id=第一部分-pc的启动>第一部分 PC的启动<a hidden class=anchor aria-hidden=true href=#第一部分-pc的启动>#</a></h2><p>整个使用都运行在QEMU模拟器上，该模拟器可以每行调试代码，比较方便的观察到整个系统的启动情况，以及操作系统做了啥；</p><h3 id=练习1>练习1<a hidden class=anchor aria-hidden=true href=#练习1>#</a></h3><pre><code>首先告诉你该练习目的是要你熟悉汇编语言、PC启动过程、和QEMU模拟器的调试过程。没什么实质的内容，直接下一个
</code></pre><h3 id=pc的物理地址空间>PC的物理地址空间<a hidden class=anchor aria-hidden=true href=#pc的物理地址空间>#</a></h3><p>在早期的PC中，CPU是16bits的8088处理器，只支持访问1MB的物理内存，物理地址空间从0x00000000到0x000FFFFF而不是0xFFFFFFFF,低640KB的空间被标记为low memory，作为RAM使用；</p><p>从0x000A0000到0x00FFFFF，被保留作为硬件外设，比如VGA的缓冲区，这个区域保留着最重要的BIOS（基本输入输出系统），占64KB从0x000FF0000开始，到0x000FFFFFF，早期的PC中，BIOS是只读的，现在BIOS都存在FLash中，是可以多次写入的，BIOS的主要功能是系统的基本初始化，包括显卡、内存大小。在这些初始化之后，BIOS将从硬盘中加载操作系统；</p><pre tabindex=0><code>
+------------------+  &lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  &lt;- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</code></pre><p>虽然CPU的支持更大的寻址空间，为了兼容之前写的BIOS，前1MB的物理地址的布局还是被保留了下来；</p><h3 id=rom中的bios>ROM中的BIOS<a hidden class=anchor aria-hidden=true href=#rom中的bios>#</a></h3><p>这一小节，要用gdb调试BIOS启动过程；</p><p>tu<br>可以看到第一条指令就是</p><pre tabindex=0><code>[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b
</code></pre><p>从打印的指令可以看到：</p><ul><li>首先PC在物理地址0x000ffff0的位置启动，这在BIOS的存储Rom中是非常高的位置；</li><li>启动时的状态是 CS = 0xf000（代码段寄存器） IP = 0xfff0(指令指针寄存器)；</li><li>第一条指令是jmp指令，将CS = 0xf000, IP = 0xe05b；<br>首先这个物理地址0x000ffff0是一个固定值，不过为什么放在这个高的位置，是一个问题，其次，ROM如何映射到这个地址，也是一个问题；
接下来就是对CPU寻址模式的一个解释：总的来说</li></ul><pre tabindex=0><code>物理地址 =  代码段地址 &lt;&lt; 4 + 指令指针寄存器偏移量
</code></pre><p>为什么要这样做？因为此时CPU还是16bits寻址空间，数据总线是8bits，纯按这个方式寻址，最大的寻址空间是2^16 * 1 = 64KB，可是当前状态的CPU可以用的物理内存有1MB，需要20bits的寄存器，于是用这样一个段 + 偏移量的形式，避免了实际可用内存大于寻址空间的问题。</p><h3 id=练习二>练习二<a hidden class=anchor aria-hidden=true href=#练习二>#</a></h3><pre><code>使用GDB跟踪几条指令，猜测BIOS在干吗，其实也没实际的内容；
</code></pre><h2 id=第二部分-boot-loader>第二部分 Boot loader<a hidden class=anchor aria-hidden=true href=#第二部分-boot-loader>#</a></h2><p>对于PC来说，硬盘被划分为512byte的区域，叫做扇区，扇区是一次磁盘操作的最小区域，如果该磁盘是可启动的，该磁盘第一个扇区叫做启动扇区，也就是bootloader代码的存储区域。当BIOS找到这个可以启动的扇区时，他将这个512byte扇区的内容加在到0x7c00到0x7dff，然后通过<code>jmp CS:IP</code>指令调到这个区域，此时就完成的BIOS到BootLoader的转换，这些地址就像BIOS启动区域一样，都是人为自由规定的，但是对PC来说，是固定的；<br>在6.828的实验中，Bootloader包括一个汇编源文件boot/boot.S，与.c文件 boot/main.c, BootLoader的主要目的有两个：</p><ul><li>将处理器从实模式切换到32bits的保护模式，这两者的主要区别给出的参考资料中有介绍，主要是寻址空间从1MB扩展到4GB，其次是引入了虚拟内存的分页内存机制；</li><li>Bootloader通过x86的特定IO指令，将内核从磁盘中读取出来；<br>当你看懂了bootloader的源码之后，看看obj/boot/boot.asm文件，该文件是bootloader的反汇编文件，阅读反汇编文件可以更加清晰的看到boot loader的代码所在位置，同样对于obj/kern/kernal.asm</li></ul><h3 id=练习三>练习三<a hidden class=anchor aria-hidden=true href=#练习三>#</a></h3><pre><code>设立一个断点在0x7c00,也就是bootloader所在的启动扇区的位置，继续执行直到命中这个断点，跟踪boot.s的代码，也可以使用GDB的x/i指令去获取任意机器指令的反汇编指令，对比boot.s与boot.asm的内容。

追踪到bootmain函数中，具体到readsect()函数中，将汇编指令与C语言代码进行对应，回到bootmian函数中，找到内核文件从磁盘读取到内存的for循环代码，并找到循环结束后执行的语句，并再这位置设置断点，运行到该断点，然后跟踪直到bootloader结束
</code></pre><p>要回答以下四个问题：</p><ol><li>处理器从什么时候开始执行 32 位代码？究竟是什么导致从16位模式切换到32位模式？</li><li>bootloader最后一条执行的指令是那个？ kernal执行的第一条指令是？</li><li>内核执行的第一条指令在哪里？</li><li>bootloader怎么直到他要读取多少个扇区才能吧内核加载到内存，这些信息在哪里可以找到？</li></ol><p>先看练习三，汇报代码注释其实已经写的比较详细了</p><pre tabindex=0><code>.globl start
start:
  .code16                     # Assemble for 16-bit mode
  cli                         # Disable interrupts 关中断
  cld                         # String operations increment 

  # Set up the important data segment registers (DS, ES, SS).
  xorw    %ax,%ax             # Segment number zero ax寄存器清零
  movw    %ax,%ds             # -&gt; Data Segment  用ax寄存器清零DS ES SS寄存器
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment
</code></pre><p>这几条指令主要是关闭中断，清理了DS ES SS寄存器的值；</p><pre tabindex=0><code>  # Enable A20:
  #   For backwards compatibility with the earliest PCs, physical
  #   address line 20 is tied low, so that addresses higher than
  #   1MB wrap around to zero by default.  This code undoes this.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  outb    %al,$0x60
</code></pre><p>可以看到seta20.1是一个轮询的过程，一直查询的是0x64里面的第二个bit位是否是0，inb指令是直接从硬件IO口上读取数据，这里是将0x64的IO口，读取到al寄存器中，test指令做得就是and操作， 一个数与上0x02查询的就是第1个bit位是否1，若为1，ZF寄存器就是1，jnz是jump not zero的意思，直到ZF寄存器是0，才跳出这个循环；<br>接下来是通过out指令将0xd1送到地址为0x64的IO端口中; 告诉cpu，下一行命令写到0x60寄存器，并且要被写到804x输出端口上，后续操作与之前相同，再次查询0x64的bit1位是否为1，也就是查询数据写入是否成功，如果成功，接下来就再向0x60口，写入0xdf；
具体含义参考这个网站：https://bochs.sourceforge.io/techspec/PORTS.LST<br>接下来代码：</p><pre tabindex=0><code>  # Switch from real to protected mode, using a bootstrap GDT
  # and segment translation that makes virtual addresses 
  # identical to their physical addresses, so that the 
  # effective memory map does not change during the switch.
  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE_ON, %eax
  movl    %eax, %cr0

  # Bootstrap GDT
  .p2align 2                                # force 4 byte alignment
  gdt:
    SEG_NULL				# null seg
    SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg
    SEG(STA_W, 0x0, 0xffffffff)	        # data seg

  gdtdesc:
    .word   0x17                            # sizeof(gdt) - 1
    .long   gdt                             # address gdt
</code></pre><h4 id=gdt表>GDT表<a hidden class=anchor aria-hidden=true href=#gdt表>#</a></h4><p>接下来就是一个比较重要的概念了：gdt（global Descriptor Table 全局描述表），它是一种结构体数据，被用于定义内存分段，比如，代码段，数据段。对不同的段限制其相应的操作限制，也就是rwx；<br>从代码中看到，他先使用指令lgdt，将gdtdesc地址存到全局描述表寄存器中；这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器由48位组成，其中低16位表示该表长度，高32位表该表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的最后一个位置的偏移量和起始地址。我们可以在这个文件的末尾看到gdtdesc；<br>gdt表中包含三个种类，nullseg、codeseg、dataseg，xv6没有分段机制，代码段与数据段都是放在一起的，都可以使用0x00到0xffffffff = 4G内存;
那么这三种类有什么不同，这里是通过宏定义SEG（在inc/mmu.h中）来初始化，主要包括读、写、执行权限，存储的起始地址与最大地址；</p><p>在初始化gdt后，后续的几条指令就很简单了，把寄存器CR0的值取出来，逻辑或0x01，再写入CR0中，在inc/mmu.h中，该值就是启动保护模式的意思；</p><p>后续执行的就是32位模式的跳转工作，跳转到保护模式下的代码段，IP寄存器直接指向标志符protcseg，再使用数据段初始化其余段寄存器，包括DS、SS等寄存器；</p><pre tabindex=0><code>  # Jump to next instruction, but in 32-bit code segment.
  # Switches processor into 32-bit mode.
  ljmp    $PROT_MODE_CSEG, $protcseg

  .code32                     # Assemble for 32-bit mode
protcseg:
  # Set up the protected-mode data segment registers
  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  
  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call bootmain
</code></pre><p>在boot.s最后，使用call指令，调用bootmain函数，在反汇编文件obj/boot/boot.asm中可以看到，函数名就是一个指令地址，调用前后的esp、eip地址对比如下图,调用前，eip指向是当前指令地址，执行call之后，栈中被推入了<code>call bootmain</code> 下一条指令的地址，作为函数返回地址，同时在新函数的开头，更新ebp的值，<code>push %esp, mov %esp, %ebp</code>作为被调用函数的栈顶,以上就是一般函数调用的过程;</p><p><img loading=lazy src=callBootmian.png alt=图片1></p><pre tabindex=0><code>	readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
    7d2e:	52                   	push   %edx
    7d2f:	6a 00                	push   $0x0
    7d31:	68 00 10 00 00       	push   $0x1000
    7d36:	68 00 00 01 00       	push   $0x10000
    7d3b:	e8 a2 ff ff ff       	call   7ce2 &lt;readseg&gt;
</code></pre><p>readseg(),前面三条指令是形参的初始化，这里就可以看到，形参的初始化顺序是从后往前初始化的，且是由调用者进行初始化，接下来就进入readseg函数中，bootmain主要的流程，先读一个page，也就是4096个字节，首先校验ELF的magic是否正确，如果正确就从该结构体中的另一个成员中读到起始地址与大小，然后调用readseg函数从磁盘中加载内核，然后将entry这个成员作为函数指针进行调用，此时已经进行操作系统内核；</p><p>这小节后续还需要再细化分析；</p><h3 id=小总结>小总结<a hidden class=anchor aria-hidden=true href=#小总结>#</a></h3><p>这部分练习内容，主要是要你理解一下bootloader的主要工作，那么现在可以主要总结一下，BootLoader的主要工作包括：</p><ul><li>CPU的工作模式从实模式到保护模式的切换；由于现在还没有MMU，主要是通过GDT进行读、写、执行的权限管理，目前保护模式只区分了代码段与数据段，也没有在内存中将其区分，这部分对应的代码是boot.s部分；</li><li>从硬盘指定的地址将内核加载到内存中，具体方式是，先读4096个字节，这其中就包括内核一些信息，包括magicnum（校验数字）、内核起始地址，大小等，如果校验成功，根据这些信息从硬盘中读取一定数量的字节加载到内存，读取完毕之后，通过elf结构体中的entry这个函数入口进入操作系统的内核，由此进入了操作系统内核；</li></ul><h3 id=加载内核>加载内核<a hidden class=anchor aria-hidden=true href=#加载内核>#</a></h3><h4 id=练习四>练习四<a hidden class=anchor aria-hidden=true href=#练习四>#</a></h4><pre><code>C语言学习，在书中《The C Programming Language》中，阅读5.1到5.5节。然后下载pointers.c的代码，并且编译运行它，确保你理解在屏幕上打印出来的所有的值是怎么来的。尤其要重点理解第1行，第6行的指针地址是如何得到的，以及在第2行到第4行的值是如何得到的，还有为什么在第5行打印出来的值看起来像程序崩溃了。
</code></pre><p>这里首先介绍了一下ELF文件，参考https://en.wikipedia.org/wiki/Executable_and_Linkable_Format，或者直接在inc/elf.h中的struct可以看到该类文件的固定长度的elf头，其中包括elf文件的分段方式，包括.text段、.rodata段、.data段、.bss段等，具体可以参考https://zhuanlan.zhihu.com/p/348026261；</p><h4 id=练习五>练习五<a hidden class=anchor aria-hidden=true href=#练习五>#</a></h4><pre><code>在boot/Makefrag文件中，修改链接地址，使用GDB追踪修改链接后的BootLoader，看看是否有问题；
</code></pre><p>这里大概涉及到的是重定向的知识，暂时不太明白；</p><h4 id=练习六>练习六<a hidden class=anchor aria-hidden=true href=#练习六>#</a></h4><pre><code>这个练习中，需要将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启一下Qemu。在Bios进入boot loader之前，内存地址0x00100000处8个字的内容，然后进入boot loader运行到内核开始处停止，再看下这个地址处的值。为什么二者不同？第二次这个内存处所存放的值的含义是什么？
</code></pre><p>首先内核程序的入口地址是0x1000c,这点可以使用<code>objdump -f obj/kern/kernel</code>可以得到内核程序的入口；<br>实验结果如下图：<br><img loading=lazy src=exercise6.png alt=图片1><br>可以看到刚进入bootloader，内存地址0x100000之后存的都是0，运行到内核入口之前，内存地址存的值已经不是0了，从<code>obj/kern/kernel.asm</code>中可以看到，这个已经是内核的代码段的内容了，在bootloader将内核加载到内存之后，这个内存的值已经得到了修改；</p><h2 id=第三部分-内核>第三部分 内核<a hidden class=anchor aria-hidden=true href=#第三部分-内核>#</a></h2><p>在之前的objdump的练习中，已经看到了VMA与LMA的不同，也就是加载地址与链接地址的不同，这里我们需要深入探究一下；</p><h3 id=使用虚拟地址空间>使用虚拟地址空间<a hidden class=anchor aria-hidden=true href=#使用虚拟地址空间>#</a></h3><h4 id=练习7>练习7<a hidden class=anchor aria-hidden=true href=#练习7>#</a></h4><pre><code>使用GDB跟踪内核代码，停在`movl %eax, %cr0`，查看内存0x00100000与0xf0100000，执行完这条语句后，再次查看这两个内存,解释一下为什么是这个样子的
</code></pre><p>这条语句就是启动内存映射的一个地址，在此之前内核还未建立起内存映射关系，在此之后，建立了内存映射关系，两个地址被映射到相同的物理地址中,具体如何实现看下反汇编代码：</p><pre tabindex=0><code>	# sufficient until we set up our real page table in mem_init
	# in lab 2.

	# Load the physical address of entry_pgdir into cr3.  entry_pgdir
	# is defined in entrypgdir.c.
	movl	$(RELOC(entry_pgdir)), %eax
f0100015:	b8 00 90 11 00       	mov    $0x119000,%eax
	movl	%eax, %cr3
f010001a:	0f 22 d8             	mov    %eax,%cr3
	# Turn on paging.
	movl	%cr0, %eax
f010001d:	0f 20 c0             	mov    %cr0,%eax
	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
f0100020:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl	%eax, %cr0
f0100025:	0f 22 c0             	mov    %eax,%cr0

	# Now paging is enabled, but we&#39;re still running at a low EIP
	# (why is this okay?).  Jump up above KERNBASE before entering
	# C code.
	mov	$relocated, %eax
f0100028:	b8 2f 00 10 f0       	mov    $0xf010002f,%eax
	jmp	*%eax
f010002d:	ff e0                	jmp    *%eax

f010002f &lt;relocated&gt;:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
</code></pre><p>总的来说，先把entry_dir的地址存到cr3寄存器中作为一级页表，然后在启动内存映射模式，这里有个小问题，就是启动内存映射模式后，EIP如何还能正确被映射到指向下一个指令：</p><pre tabindex=0><code>__attribute__((__aligned__(PGSIZE)))
pde_t entry_pgdir[NPDENTRIES] = {
	// Map VA&#39;s [0, 4MB) to PA&#39;s [0, 4MB)
	[0]
		= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P,
	// Map VA&#39;s [KERNBASE, KERNBASE+4MB) to PA&#39;s [0, 4MB)
	[KERNBASE&gt;&gt;PDXSHIFT]
		= ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W
};
</code></pre><p>由虚拟内存的地址机制，高10位是entry_pgdir的偏移量，这个entry_pgdir只初始化了两个内容，entry_pgdir[0]与entry_pgdir[960]，正好对应的是0x00100028与0xf0100028中高10位数值，他们内容（除了权限问题之外）是一样的，说明这两个一级页表映射的地址区间是同一个page，于是EIP的虚拟内存映射之后，地址没有变化，如同entry_pgdir注释所示；</p><h3 id=格式化打印至控制台>格式化打印至控制台<a hidden class=anchor aria-hidden=true href=#格式化打印至控制台>#</a></h3><h3 id=练习8>练习8<a hidden class=anchor aria-hidden=true href=#练习8>#</a></h3><pre><code>补全printf()函数的%o的情况
</code></pre><p>还需要回答这些问题：</p><ol><li>解释<code>printf.c</code>与<code>console.c</code>，特别是<code>console.c</code>那些函数被导出，他们是怎么被<code>printf.c</code>调用？</li><li>解释<code>console.c</code>中的下列语句的含义：</li></ol><pre tabindex=0><code>  if (crt_pos &gt;= CRT_SIZE) {
        int i;
        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
        for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)
                crt_buf[i] = 0x0700 | &#39; &#39;;
          crt_pos -= CRT_COLS;
  }
</code></pre><ol start=3><li>跟踪以下代码</li></ol><pre tabindex=0><code>int x = 1, y = 3, z = 4;
cprintf(&#34;x %d, y %x, z %d\n&#34;, x, y, z);
</code></pre><ol start=4><li>执行以下代码</li></ol><pre tabindex=0><code>  unsigned int i = 0x00646c72;
  cprintf(&#34;H%x Wo%s&#34;, 57616, &amp;i);
</code></pre><p>输出的的字符是啥，为什么？
5. <code>cprintf("x=%d y=%d", 3);</code>输出是啥，为什么？</p><ol start=6><li>假设GCC的形参默认初始化顺序是，从左到右，如何更改cprintf函数的接口，以便于可变数量的参数传递给该函数;</li></ol><p>这个练习很简单，直接将%u系列的复制下来，将base改成8就可以；</p><pre tabindex=0><code>case &#39;o&#39;:
  num = getint(&amp;ap, lflag);
  base = 8;
  goto number;
</code></pre><p>接下来回答问题:</p><ol><li><p>从代码中就可以看到，从函数printf.c中通过函数指针调用putch()，而putch函数中调用cputchar函数是console.c中的函数接口，用于输出一个字符串；</p></li><li><p>这段代码的主要目的是，如果屏幕的字符串长度大于显示的最大字符串，首先使用memmove将整体将buf前移动一行（宏定义为80 * 2个字节），这里必须使用memmove，因为内存区域是有重叠的，memcpy会导致数据错误的，然后将最后一行的数据用空格填充，将当前字符串位置减去一行大小；</p></li><li><p>这里其实是考察GCC默认的形参初始化方式，从汇编代码来看，默认的形参初始化方式是从右往左进行入栈初始化的,并且可以看到指针操作的具体是通过lea命令进行实现的；</p></li></ol><pre tabindex=0><code>	//lab1 exercise 8
	int x = 1, y = 3, z = 4;
	cprintf(&#34;x %d, y %x, z %d\n&#34;, x, y, z);
f01000f0:	6a 04                	push   $0x4
f01000f2:	6a 03                	push   $0x3
f01000f4:	6a 01                	push   $0x1
f01000f6:	8d 83 6a 08 ff ff    	lea    -0xf796(%ebx),%eax
f01000fc:	50                   	push   %eax
f01000fd:	e8 9b 09 00 00       	call   f0100a9d &lt;cprintf&gt;
</code></pre><ol start=4><li>跑出来的效果是</li></ol><pre tabindex=0><code>x 1, y 3, z 4
He110 World
x=3 y=-267321364
</code></pre><p>57616的16进制就是110，这个没啥好说的，关键是0x00646c72按照%s打印是rld，这个就涉及到计算机的存储形式了，计算机按照小端序列进行存储，也就是说i = 0x00646c72实际存储方式，地址从低到高分别是72 6c 64 00形式,其ASC码值对应就是字符串"rld\0"，所以打印出来为He110 World了；</p><ol start=5><li><p>y=之后打印出来的数字是之前栈中使用的数字，但是并无实际意义，这个问题是告诉你，printf对于参数缺省的情况下的实际运行情况与原理；</p></li><li><p>这种情况只能声明一个参数数量这个变量；（函数可变数量形参这里还要继续看）</p></li></ol><h4 id=栈>栈<a hidden class=anchor aria-hidden=true href=#栈>#</a></h4><h4 id=练习9>练习9<a hidden class=anchor aria-hidden=true href=#练习9>#</a></h4><pre><code>找到哪里是内核初始化的代码，内核的栈起点在哪里，内核栈的保留的区域的终点在哪里？
</code></pre><p>ebp（基指针）寄存器主要通过软件习惯与堆栈相关联。 在进入 C 函数时，函数会更新ebp的地址，表示这里才是该函数栈的起点，那么在程序执行期间的任何变量，都可以通过跟踪保存的ebp要到达的程序中的点。 此功能可能特别有用，例如，当某个特定函数由于传递了错误参数而导致异常时，但您不确定是谁传递了错误参数。堆栈回溯可让您找到有问题的函数。</p><p>回答：
内核初始化栈是是entry.S中语句</p><pre tabindex=0><code>movl	$0x0,%ebp			# nuke frame pointer
# Set the stack pointer
movl	$(bootstacktop),%esp
</code></pre><p>栈的大小在<code>inc/memlayout.h</code>中定义为8 * 4096大小，也就是32KB；（目前还不确定是为什么ebp在0x00，esp大于ebp）</p><h4 id=练习10>练习10<a hidden class=anchor aria-hidden=true href=#练习10>#</a></h4><pre><code>为了熟悉C语言调用函数的规则，找到test_backtrace函数，设一个断点，检验每次调用这个函数时，每层嵌套有有多少个32bits字段被推入栈中，这些字段代表什么意思？
</code></pre><p>这个实验只需要在test_backtrace()函数中打印出ebp与esp的值就行了，打印结果为：</p><pre tabindex=0><code>entering test_backtrace 5
ebp = 0xf010ffd8, esp = 0xf010ffc0
entering test_backtrace 4
ebp = 0xf010ffb8, esp = 0xf010ffa0
entering test_backtrace 3
ebp = 0xf010ff98, esp = 0xf010ff80
entering test_backtrace 2
ebp = 0xf010ff78, esp = 0xf010ff60
entering test_backtrace 1
ebp = 0xf010ff58, esp = 0xf010ff40
entering test_backtrace 0
ebp = 0xf010ff38, esp = 0xf010ff20
</code></pre><p>可以看到每次进行函数调用压栈的32bits的字段为32个,其中函数栈帧中，从上到下分别是，临时变量，调用其他函数的形参，调用返回值，函数调用者的ebp地址；</p><h4 id=练习11>练习11<a hidden class=anchor aria-hidden=true href=#练习11>#</a></h4><pre><code>完成一个回溯函数，打印ebp、eip和形参值，eip存的是函数返回指令指针，也就是函数返回时将要接管的指令地址，这个值通常指向call指令的下一条指令，为什么？最后，五个十六进制数字，那些是在函数调用前应该被压入栈中的，如果函数形参少于五个呢？（为什么回溯函数不能知道到底有几个形参，这样的局限性应该怎么样被修复）
</code></pre><p>需要补全的是mon_backtrace函数，主要的问题在于，循环的结束条件吧，读取ebp值可以直接使用read_ebp函数，根据上一个练习的结果，eip的存储地址就是当前函数ebp + 1存储地址，再接着往上就是所用的形参了，此时需要一直回溯到内核启动的函数，也就是第一次设置ebp函数，在练习9中知道第一次设置ebp为0x00；(为什么要保存调用者的ebp的值，只是为了调试还是其他的目的)<br><img loading=lazy src=%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%a0%88%e7%bb%93%e6%9e%84.jpg alt=图片><br>其次，这里的read_ebp函数被声明为inline函数，从汇编上可以看到，inline函数没有使用call命令，而是就地修改了代码，避免了函数调用的开销（形参入栈，eip入栈，局部变量等）；</p><pre tabindex=0><code>int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
	// Your code here.
	cprintf(&#34;Stack backtrace:\n&#34;);
	for (uint32_t ebp = read_ebp(); ebp != 0x00 ; ebp = *((uint32_t *)ebp)){
		cprintf(&#34;  ebp %08x eip %08x  args %08x %08x %08x %08x %08x\n&#34;, 
		ebp, *((uint32_t *)ebp + 1), *((uint32_t *)ebp + 2), *((uint32_t *)ebp + 3), 
		*((uint32_t *)ebp + 4), *((uint32_t *)ebp + 5), *((uint32_t *)ebp + 6));
	}
	return 0;
}
</code></pre><h4 id=练习12>练习12<a hidden class=anchor aria-hidden=true href=#练习12>#</a></h4><pre><code>修改栈的回溯函数，对每个eip，找到他的函数名称，源文件名称，行数。
在debuginfo_eip，__STAB_*从哪里来，这个问题先不考虑。现在要完成debuginfo_eip函数，通过二分查找函数stab_binsearch函数找到函数行号；
在你的操作系统中加入backtrace命令，并且实现mon_backtrace函数，调用debuginfo_eip，打印按照固定的格式打印每个栈帧：
K&gt; backtrace
Stack backtrace:
  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000
        kern/monitor.c:143: monitor+106
  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000
        kern/init.c:49: i386_init+59
  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff
        kern/entry.S:70: &lt;unknown&gt;+0
K&gt;
每行栈帧的eip的文件名字，与行号，接着给出函数名称，和eip相对该函数首条指令的偏移量(monitor+106表示eip相对于monitor函数首行有106字节的偏移量)
tip：打印字符串的前n个字符可以使用printf(&quot;%.*s&quot;, length, string)
</code></pre><p>这个练习中debuginfo_eip是copy的：</p><pre tabindex=0><code>  stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);
	if (lline &lt;= rline){
		info-&gt;eip_line = stabs[lline].n_desc;
	}else{
		cprintf(&#34;line not find\n&#34;);
	}
</code></pre><p>后续的mon_backtrace函数直接每次调用debuginfo_eip函数，再将信息打印出来即可：</p><pre tabindex=0><code>int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
	// Your code here.
	cprintf(&#34;Stack backtrace:\n&#34;);
	for (uint32_t ebp = read_ebp(); ebp != 0x00 ; ebp = *((uint32_t *)ebp)){
		uint32_t eipAddr = *((uint32_t *)ebp + 1);
		cprintf(&#34;  ebp %08x eip %08x  args %08x %08x %08x %08x %08x\n&#34;, 
		ebp, eipAddr, *((uint32_t *)ebp + 2), *((uint32_t *)ebp + 3), 
		*((uint32_t *)ebp + 4), *((uint32_t *)ebp + 5), *((uint32_t *)ebp + 6));
		struct Eipdebuginfo info;
		debuginfo_eip(eipAddr, &amp;info);
		cprintf(&#34;         %s:%d: %.*s+%d\n&#34;, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eipAddr - info.eip_fn_addr);
		
	}
	
	return 0;
}
</code></pre><p>最后加入新的命令需要看明白monitor函数与runcmd函数，monitor函数每次都从命令行中读取数据，调用runcmd函数，runcmd其实就是做了一个字符串匹配的工作，匹配从静态结构体数组中<code>static struct Command commands[] </code>匹配函数名，argc argv等变量，再通过该结构体数组中的函数指针调用该函数，弄清楚这个，加入新的命令就很简单了，就是在这个数组中加入函数名称、描述，以及指向对应函数的指针；<br>至此，lab1总算是磕磕绊绊的做完了。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>总的来说，lab1做完了解到很多知识，比较有用的是汇编语句（可以再看一遍csapp）、系统栈的管理方式（包括回溯的汇编代码的实现），函数调用规则，包括页表的建立与原理，还没弄明白的是链接与重定向的方面的内容：下图是这个实验主要内容&ndash;PC启动的大致总结。<br><img loading=lazy src=%e6%80%bb%e7%bb%93.png alt=图片></p><h1 id=网上找到的资料记录一下>网上找到的资料记录一下<a hidden class=anchor aria-hidden=true href=#网上找到的资料记录一下>#</a></h1><ul><li><p><a href=https://www.cnblogs.com/fatsheep9146/category/769143.html>https://www.cnblogs.com/fatsheep9146/category/769143.html</a></p></li><li><p>全局描述表
<a href=https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8>https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8</a> <a href=https://www.geeksforgeeks.org/what-is-global-descriptor-table/>https://www.geeksforgeeks.org/what-is-global-descriptor-table/</a> <a href=https://wiki.osdev.org/Global_Descriptor_Table>https://wiki.osdev.org/Global_Descriptor_Table</a> <a href=https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table>https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table</a></p></li><li><p>函数调用
<a href=https://www.tutorialspoint.com/assembly_programming/assembly_procedures.htm>https://www.tutorialspoint.com/assembly_programming/assembly_procedures.htm</a> <a href=https://zhuanlan.zhihu.com/p/24129384>https://zhuanlan.zhihu.com/p/24129384</a> <a href=https://blog.csdn.net/theLostLamb/article/details/79950815>https://blog.csdn.net/theLostLamb/article/details/79950815</a> <a href=https://segmentfault.com/a/1190000016661251>https://segmentfault.com/a/1190000016661251</a></p></li><li><p>页表
<a href=https://en.wikipedia.org/wiki/Control_register>https://en.wikipedia.org/wiki/Control_register</a> <a href=https://pdos.csail.mit.edu/6.828/2018/readings/i386/s05_02.htm>https://pdos.csail.mit.edu/6.828/2018/readings/i386/s05_02.htm</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://examplesite.com/tags/first/>first</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Test on twitter" href="https://twitter.com/intent/tweet/?text=Test&url=https%3a%2f%2fexamplesite.com%2ftest%2f&hashtags=first"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Test on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fexamplesite.com%2ftest%2f&title=Test&summary=Test&source=https%3a%2f%2fexamplesite.com%2ftest%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Test on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexamplesite.com%2ftest%2f&title=Test"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Test on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexamplesite.com%2ftest%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Test on whatsapp" href="https://api.whatsapp.com/send?text=Test%20-%20https%3a%2f%2fexamplesite.com%2ftest%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Test on telegram" href="https://telegram.me/share/url?text=Test&url=https%3a%2f%2fexamplesite.com%2ftest%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://examplesite.com/>ExampleSite</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>